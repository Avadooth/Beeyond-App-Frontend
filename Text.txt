frontend/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html             # Root HTML template
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Navbar.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderCard.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CustomerDashboard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DeliveryDashboard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AdminPanel.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoginPage.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js             # Axios setup
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authService.js     # JWT auth logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.js                 # Route entry point
‚îÇ   ‚îú‚îÄ‚îÄ nginx/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ default.conf           # Nginx config for reverse proxy
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile                 # Dockerfile for frontend build
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js             # Or next.config.js if using Next.js
‚îÇ
‚îú‚îÄ‚îÄ .env                           # Shared environment variables
‚îú‚îÄ‚îÄ docker-compose.yml             # Orchestration of all services
‚îî‚îÄ‚îÄ README.md                      # Full documentation


I have a basic React component styled with inline CSS or minimal Tailwind classes. Rewrite it in a production-grade style that mimics the visual and interactive design of https://www.beeyond.agency. Follow these exact rules:

1. Use Tailwind CSS utility classes for layout, spacing, typography, and colors.
2. Apply a modern **dark mode theme**: backgrounds like `bg-gray-900`, `bg-black`, and `text-white`.
3. Add clean, bold typography using `text-4xl`, `font-extrabold`, `tracking-wide`, etc.
4. Use elegant gradient accents like `bg-gradient-to-r from-purple-600 to-blue-400` where suitable.
5. Add hover effects such as `hover:scale-105`, `hover:shadow-xl`, and `transition-all duration-300`.
6. Make the layout fully responsive using Tailwind‚Äôs grid and flex utilities.
7. Add smooth **scroll-triggered animations** using **Framer Motion** (or Intersection Observer).
8. Replace generic HTML elements with semantic and accessible markup.
9. Output only clean, modern JSX with Tailwind classes, no inline styles.
10. Maintain accessibility (alt tags, semantic tags, keyboard-friendly buttons).





import { useEffect, useState } from "react";
import ProductCard from "../components/ProductCard";
import api from "../services/api";
import socket from "../socket.js";

export default function CustomerDashboard() {
  const [products, setProducts] = useState([]);

  useEffect(() => {
    fetchProducts();
    // Fake product data ‚Äî replace this with API call later
  }, []);

  const fetchProducts = async () => {
    try {
      const response = await api.get("https://dummyjson.com/products");
      setProducts(response.data.products);
    } catch (err) {
      console.error("Failed to fetch products:", err);
      alert("‚ùå Failed to load products");
    }
  };

  const handleBuy = async (product) => {
    debugger;
    try {
      const token = localStorage.getItem("token");
      const res = await api.post(
        "/orders/BuyOrder",
        {
          productId: product.id,
          productName: product.title,
          productPrice: product.price,
        },
        { headers: { Authorization: Bearer ${token} } }
      );
      socket.emit("newOrderPlaced", res.data);
      alert(‚úÖ Order placed for: ${product.title}); 
    } catch (err) {
      console.error("Order failed:", err);
      alert("‚ùå Failed to place order");
    }
  };

  return (
    <section className="min-h-screen bg-gray-900 text-white py-16 px-6">
      <div className="max-w-6xl mx-auto">
        <h2 className="text-4xl font-extrabold tracking-wide text-center mb-10 bg-gradient-to-r from-purple-600 to-blue-400 text-transparent bg-clip-text">
          Available Products
        </h2>

        <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3">
          {products.map((product) => (
            <ProductCard key={product.id} product={product} onBuy={handleBuy} />
          ))}
        </div>
      </div>
    </section>
  );
}

import { useEffect, useState, useRef } from "react";
import { motion } from "framer-motion";
import api from "../services/api";
import socket from "../socket"; // shared socket instance

export default function DeliveryDashboard() {
  const [orders, setOrders] = useState([]);
  const incomingOrdersRef = useRef([]); // store incoming new orders
  const orderIdsRef = useRef(new Set());

  useEffect(() => {
    let isMounted = true;

    // Fetch orders
    api.get("/orders/partnerOrders").then((res) => {
      if (isMounted) {
        setOrders(res.data);

        // Join socket rooms for each order
        res.data.forEach((order) => {
          orderIdsRef.current.add(order._id);
          socket.emit("joinOrderRoom", { orderId: order._id });
        });
      }
    });

    const processNewOrders = () => {
      setOrders((prev) => {
        const newOnes = incomingOrdersRef.current.filter(
          (order) => !orderIdsRef.current.has(order._id)
        );

        newOnes.forEach((o) => orderIdsRef.current.add(o._id));

        incomingOrdersRef.current = []; // reset
        return [...prev, ...newOnes];
      });
    };
    const debounceTimer = setInterval(() => {
      if (incomingOrdersRef.current.length > 0) {
        processNewOrders();
      }
    }, 500);

    // Listen to status updates
    socket.on("orderStatusUpdate", ({ orderId, status }) => {
      setOrders((prev) =>
        prev.map((order) =>
          order._id.toString() === orderId.toString()
            ? { ...order, status }
            : order
        )
      );
    });
    socket.on("newOrder", (order) => {
      console.log("üì¨ Partner received newOrder via socket:", order);

      incomingOrdersRef.current.push(order);
    });

    return () => {
      isMounted = false;
      clearInterval(debounceTimer);
      socket.off("orderStatusUpdate");
      socket.off("newOrder");
    };
  }, []);

  const handleAccept = async (orderId) => {
    try {
      await api.post(/orders/${orderId}/accept);
      socket.emit("joinOrderRoom", { orderId }); // optional: join after accepting
      alert("Order accepted");
    } catch (err) {
      alert("Order already taken");
    }
  };

  const handleStatusChange = (orderId, status) => {
    console.log("Updating order status:", orderId, status);
    socket.emit("updateOrderStatus", { orderId, status });
  };

  const pendingOrders = orders.filter((order) => order.status === "pending");
  const acceptedOrders = orders.filter((order) => order.status !== "pending");

  return (
    <section className="min-h-screen bg-gray-900 text-white py-16 px-4 sm:px-8">
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        whileInView={{ opacity: 1, y: 0 }}
        viewport={{ once: true }}
        transition={{ duration: 0.6 }}
        className="max-w-6xl mx-auto"
      >
        <h2 className="text-4xl sm:text-5xl font-extrabold tracking-wide mb-10 text-center bg-gradient-to-r from-purple-500 to-blue-400 text-transparent bg-clip-text">
          Delivery Dashboard
        </h2>

        {/* Unaccepted Orders */}
        <div className="mb-14">
          <h3 className="text-2xl font-semibold text-purple-400 mb-4">
            üü° Unaccepted Orders
          </h3>
          {pendingOrders.length === 0 ? (
            <p className="text-gray-400">No unaccepted orders available.</p>
          ) : (
            <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3">
              {pendingOrders.map((order) => (
                <motion.article
                  key={order._id}
                  whileHover={{ scale: 1.03 }}
                  className="bg-gray-800 border border-gray-700 rounded-xl p-6 shadow-md hover:shadow-xl transition-all duration-300"
                >
                  <h3 className="text-xl font-bold mb-2 bg-gradient-to-r from-purple-500 to-blue-400 text-transparent bg-clip-text">
                    Order #{order.productId}
                  </h3>
                  <p className="text-gray-300 mb-2">
                    <span className="font-semibold text-white">Product:</span>{" "}
                    {order.productName}
                  </p>
                  <p className="text-gray-300 mb-4">
                    <span className="font-semibold text-white">Status:</span>{" "}
                    {order.status}
                  </p>
                  <button
                    onClick={() => handleAccept(order._id)}
                    className="w-full py-2 px-4 bg-gradient-to-r from-purple-600 to-blue-500 hover:from-purple-700 hover:to-blue-600 rounded-md font-semibold transition-all duration-300"
                  >
                    Accept Order
                  </button>
                </motion.article>
              ))}
            </div>
          )}
        </div>

        {/* Accepted Orders */}
        <div>
          <h3 className="text-2xl font-semibold text-green-400 mb-4">
            üü¢ Your Accepted Orders
          </h3>
          {acceptedOrders.length === 0 ? (
            <p className="text-gray-400">No accepted orders yet.</p>
          ) : (
            <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3">
              {acceptedOrders.map((order) => (
                <motion.article
                  key={order._id}
                  whileHover={{ scale: 1.03 }}
                  className="bg-gray-800 border border-gray-700 rounded-xl p-6 shadow-md hover:shadow-xl transition-all duration-300"
                >
                  <h3 className="text-xl font-bold mb-2 bg-gradient-to-r from-green-400 to-blue-400 bg-clip-text text-transparent">
                    Order #{order.productId}
                  </h3>
                  <p className="text-gray-300 mb-2">
                    <span className="font-semibold text-white">Product:</span>{" "}
                    {order.productName}
                  </p>
                  <p className="text-gray-300 mb-4">
                    <span className="font-semibold text-white">Status:</span>{" "}
                    {order.status}
                  </p>
                  <div className="flex flex-col space-y-2">
                    {order.status === "accepted" && (
                      <button
                        onClick={() =>
                          handleStatusChange(order._id, "picked-up")
                        }
                        className="w-full py-2 px-4 bg-purple-600 hover:bg-purple-700 rounded-md font-semibold transition-all duration-300"
                      >
                        Picked Up
                      </button>
                    )}

                    {order.status === "picked-up" && (
                      <button
                        onClick={() =>
                          handleStatusChange(order._id, "on-the-way")
                        }
                        className="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 rounded-md font-semibold transition-all duration-300"
                      >
                        On The Way
                      </button>
                    )}

                    {order.status === "on-the-way" && (
                      <button
                        onClick={() =>
                          handleStatusChange(order._id, "delivered")
                        }
                        className="w-full py-2 px-4 bg-green-600 hover:bg-green-700 rounded-md font-semibold transition-all duration-300"
                      >
                        Delivered
                      </button>
                    )}

                    {order.status === "delivered" && (
                      <span className="inline-block mt-2 px-3 py-1 bg-green-700 text-sm text-white rounded-full">
                        ‚úÖ Delivered
                      </span>
                    )}
                  </div>
                </motion.article>
              ))}
            </div>
          )}
        </div>
      </motion.div>
    </section>
  );
}

import { Server } from "socket.io";
import Order from "../models/Order.js";

let io;

export const initSocket = (server) => {
  io = new Server(server, {
    cors: {
      origin: "http://localhost:5173", // ‚úÖ Frontend URL
      methods: ["GET", "POST", "PATCH"],
      credentials: true,
    },
  });

  io.on("connection", (socket) => {
    console.log("‚úÖ Partner connected:", socket.id);

    socket.on("joinOrderRoom", ({ orderId }) => {
      console.log("Joining room:", orderId);
      socket.join(orderId);
    });
    socket.on("newOrderPlaced", (order) => {
      console.log("üì¶ New order placed:", order._id);
      io.emit("newOrder", order); // broadcast to all connected delivery sockets
    });

    socket.on("updateOrderStatus", async ({ orderId, status }) => {
      await Order.findByIdAndUpdate(orderId, { status });
      io.to(orderId).emit("orderStatusUpdate", { orderId, status });
    });

    socket.on("disconnect", () => {
      console.log("Client disconnected:", socket.id);
    });
  });

  return io;
};

export const getIO = () => {
  if (!io) {
    throw new Error("Socket.io not initialized yet");
  }
  return io;
};

export const placeOrder = async (req, res) => {
  try {
    if (!req.user || !req.user.id) {
      return res.status(401).json({ message: "Unauthorized: user not found" });
    }
    const { productId, productName, productPrice } = req.body;

    if (!productId || !productName || !productPrice) {
      return res.status(400).json({ message: "Missing product details" });
    }

    const order = new Order({
      customerId: req.user.id,
      productId,
      productName,
      productPrice,
    });

    console.log("User:", req.user);
    console.log("Body:", req.body);

    await order.save();
    req.app.get("io").emit("newOrder", order);
    console.log("üì¢ Emitting newOrder to partners:", order);
    res.status(201).json(order);
  } catch (err) {
    console.error("‚ùå Order placement error:", err);
    res.status(500).json({
      message: "Failed to place order",
      error: err.message,
    });
  }
};


export const getPartnerOrders = async (req, res) => {
  try {
    if (req.user.role !== "partner") {
      return res.status(403).json({ message: "Access denied" });
    }
    // For partners: show orders assigned to them or still pending
    const orders = await Order.find({
      $or: [{ status: "pending" }, { partnerId: req.user.id }],
    });
    res.json(orders);
    console.log("Partner orders fetched:", orders);
  } catch (err) {
    res
      .status(500)
      .json({ message: "Error fetching delivery orders", error: err.message });
  }
}; 

